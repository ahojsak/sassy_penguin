<html>

<head>
    <link rel="stylesheet" href="http://netdna.bootstrapcdn.com/bootstrap/3.0.3/css/bootstrap.min.css">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
	<title>Final Project</title>
	<style>
		ul {
			list-style-type:none;
		}
	</style>
</head>

<body>

    <div class="row">
        <div class="col-md-2"></div>
        <div class="col-md-8">
            <div class="page-header center">
				<h1>Part 1: <small>Search Engine</small></h1>
				<h2><small>agale & ahojsak </small></h2>
            </div>

             
            <h2>Inverted Index</h2>
			<p>
				Below is a json representation of the structure of our inverted index. The index is a series of nested dictionaries indexed by the word, business identifier, and review review identifier. The inner data is a list of the positions of that word in a specific review.	
				</p>
			<ul>
			<li>{</li>
			<ul>
				<li>"word": {</li>
				<ul>
					<li>"business": {</li>
						<ul>
							<li>"review":[list of positions]</li>
						</ul>
					<li>}</li>
				</ul>
				<li>}</li>
			</ul>
			<li>}</li>
		</ul>
		<p>
			The index needed to be indexed first by the word, because a search script needs constant time lookup for all reviews containing that word. We chose to index by business and then review because the same words will probably occur in reviews for the same business. By making business a dictionary, we avoid having to repeat the business name in the index every time multiple reviews for the same business contain the same word. We index by review next because the query script will need to easily find how many times a word appears in a review and where it appears.
			</p>
			<p>
			The inverted index file we created is 595 MB. The review dataset that was used to build the inverted index is 303 MB, so our file is 195% of the original file. When our query program reads in the file, it stores the index as a json and the format of the inverted index file is optimal for retrieving the information that the query program needs.
			</p>
			<p>
			While building up the inverted index file, the review texts need to be processed. All words are converted to lowercase, and all punctuation is removed before the string is split on whitespaces.. We used a list of stopwords which we filtered out because they occur frequently yet say little. Each word is then stemmed so that all tenses of a word will be treated as equivalent. 
			</p>
			<h2>Queries</h2>
			<p>
                When a user submits a query, we first determine whether the query begins and ends with quotation marks. If so, it is treated as a phrase query; otherwise it is viewed as a one word or free text query. Before beginning the term search, common words like 'the' in the stopwords file are filtered out from the list of search terms. Each word is lowercased, stemming is applied, and punctuation is removed.
            </p>
            <p>
                One word queries and free text queries are handled in the same way. We look at each individual word's entry in the inverted index.If a single business's reviews contain every search term (without regard to the location in the reviews), that business is added to the results set.
            </p>
            <p>
                For phrase queries, we begin by looking at the inverted index entry of the first word in the query that is not a stop word. For each review and position in which the word is found we then go through each subsequent search term, checking that its position in the same review is one greater than that of the previous word. If the exact query phrase is found in a business's set of reviews, that business is then added to the results set. If a stop word is positioned between two non-stop words, then we perform the search by skipping over the stop word's position.
            </p>
			<h2>Ranking</h2>
			<p>

			</p>	

        <div class="col-md-2"></div>
    </div>

    <script src="http://d3js.org/d3.v3.min.js"></script>

</body>
</html>

